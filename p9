#! /usr/bin/python

import sys
import argparse
import re

def parse_kwargs(kwargs):
    def parse_key(key):
        key = key.replace('-', '_')

        if re.match(r'^\w+$', key):
            return ('plain-key', key)
        elif match := re.match(r'^(\w+)\.(\w+)$', key):
            return ('dict-key', match.group(1), match.group(2))
        elif match := re.match(r'^\.(\w+)$', key):
            return ('implicit-dict-key', match.group(1))
        elif match := re.match(r'^(\w+)\,$', key):
            return ('list-append', match.group(1))
        elif key == ',':
            return ('implicit-list-append',)
        else:
            raise ValueError(f'bad key: "{key}"')

    def parse_val(v):
        if v.startswith(':'):
            return v[1:]
        elif (v == '-'):
            return None
        elif (v == 'y'):
            return True
        elif (v == 'n'):
            return False
        try:
            return int(v)
        except Exception as e:
            try:
                return float(v)
            except Exception as e:
                return v

    ret = {}
    implicit_base = None
    for arg in kwargs:
        (key, val) = arg.split('=', 1)
        key = parse_key(key)
        val = parse_val(val)

        def set_dict(base, sub):
            context = ret.setdefault(base, {})
            if not isinstance(context, dict):
                raise ValueError(f'Key "{base}" already contains non-dict')
            context[sub] = val

        def set_list(base):
            context = ret.setdefault(base, [])
            if not isinstance(context, list):
                raise ValueError(f'Key "{base}" already contains non-list')
            context.append(val)

        if key[0] == 'plain-key':
            ret[key[1]] = val
            implicit_base = None
        elif key[0] == 'dict-key':
            set_dict(key[1], key[2])
            implicit_base = key[1]
        elif key[0] == 'list-append':
            set_list(key[1])
            implicit_base = key[1]
        elif key[0] == 'implicit-dict-key':
            if implicit_base is None:
                raise ValueError(f'No previous base at "{arg}"')
            set_dict(implicit_base, key[1])
        elif key[0] == 'implicit-list-append':
            if implicit_base is None:
                raise ValueError(f'No previous base at "{arg}"')
            set_list(implicit_base)
        else:
            raise RuntimeError('Bad parsed key')

    return ret

def parse_scale_kwargs(kwargs):
    kwargs = parse_kwargs(kwargs)
    if 'min' in kwargs or 'max' in kwargs:
        kwargs['limits'] = ( kwargs.pop('min', None), kwargs.pop('max', None) )
    return kwargs

def parse_command_line(argv):
    parser = argparse.ArgumentParser()

    dataset_group = parser.add_mutually_exclusive_group()
    dataset_group.add_argument('--dataset')
    dataset_group.add_argument('--input', '-i', metavar='FILE')

    parser.add_argument('--csv', nargs='+', metavar='ARG=VAL')

    parser.add_argument('--output', '-o', nargs='+',
                        metavar=('FILE', 'ARG=VAL'))

    parser.add_argument('--geom', '-g', action='append', nargs='+',
                        metavar=('GEOM', 'ARG=VAL'))
    parser.add_argument('--stat', '-s', action='append', nargs='+',
                        metavar=('STAT', 'ARG=VAL'))
    parser.add_argument('--scale', action='append', nargs='+',
                        metavar=('SCALE=TYPE', 'ARG=VAL'))
    parser.add_argument('--facet', '-f', nargs='+', metavar=('TYPE', 'ARG=VAL'))
    parser.add_argument('--theme', '-t', action='append', nargs='+',
                        metavar=('[NAME]', 'ARG=VAL'))
    parser.add_argument('--xlab')
    parser.add_argument('--ylab')
    parser.add_argument('--title')
    parser.add_argument('aes', nargs='*')

    args = parser.parse_args(argv)

    # argparse doesn't seem to let us group things to handle this automatically.
    if args.dataset is not None and args.csv is not None:
        parser.error('argument --csv: not allowed with argument --dataset')

    if args.dataset is None and args.input is None:
        args.input = '-'

    return args

def build_plot(args):
    # Don't import these unless necessary, to keep --help fast.
    import plotnine as p9
    import pandas as pd

    def get_p9(group, name):
        return getattr(p9, f'{group}_{name}')

    if args.input is not None:
        file = args.input if args.input != '-' else sys.stdin
        kwargs = parse_kwargs(args.csv or [])
        kwargs.setdefault('sep', None)
        kwargs.setdefault('engine', 'python')
        data = pd.read_csv(file, **kwargs)
    else:
        import plotnine.data
        data = getattr(plotnine.data, args.dataset)

    aes = p9.aes(**parse_kwargs(args.aes))

    plot = p9.ggplot(data, aes)

    for x in args.geom or []:
        plot += get_p9('geom', x[0])(**parse_kwargs(x[1:]))
    for x in args.stat or []:
        plot += get_p9('stat', x[0])(**parse_kwargs(x[1:]))

    for x in args.scale or []:
        (p1, p2) = x[0].split('=', 1)
        plot += get_p9('scale', f'{p1}_{p2}')(**parse_scale_kwargs(x[1:]))

    for x in args.theme or []:
        # We support both named themes (`-t xkcd stroke_size=5`)...
        if '=' not in x[0]:
            plot += get_p9('theme', x[0])(**parse_kwargs(x[1:]))

        # ...and fully custom themes (`-t plot_margin=0.2`)
        else:
            plot += p9.theme(**parse_kwargs(x))

    if args.facet is not None:
        plot += get_p9('facet', args.facet[0])(**parse_kwargs(args.facet[1:]))

    more_parts = [
        p9.ggtitle(args.title) if args.title is not None else None,
        p9.xlab(args.xlab) if args.xlab is not None else None,
        p9.ylab(args.ylab) if args.ylab is not None else None,

        # Default geom, only if no geom and stat provided.
        p9.geom_point() if not args.geom and not args.stat else None
    ]

    # `plot += [...]` doesn't work, but `plot = plot + [...]` does
    plot = plot + [x for x in more_parts if x is not None]

    return plot

def main():
    args = parse_command_line(sys.argv[1:])
    plot = build_plot(args)

    if args.output is None:
        # In a not-yet-released plotnine, `(...).draw(show=True)` will work for
        # this.
        str(plot)
    else:
        # Note: generates `PlotnineWarning`s that we probably want to suppress.
        plot.save(args.output[0], **parse_kwargs(args.output[1:]))

if __name__ == '__main__':
    main()
